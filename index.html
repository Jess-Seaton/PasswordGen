<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Password Generator (Exact-Fit Pattern + Filter)</title>
<style>
  body {
    font: 16px system-ui, sans-serif;
    margin: 2rem;
    max-width: 760px;
    background: #000;        /* Black background */
    color: #fff;             /* White text */
  }
  .row { margin: .75rem 0 }
  input[type="number"] {
    width: 6rem;
    background: #111;
    color: #fff;
    border: 1px solid #555;
    border-radius: .375rem;
    padding: .25rem .4rem;
  }
  .out {
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    padding: .75rem;
    border: 1px solid #555;
    border-radius: .5rem;
    word-break: break-all;
    background: #111;
  }
  button {
    padding: .6rem 1rem;
    border-radius: .5rem;
    border: 1px solid #ff69b4;         /* hot pink border */
    background: #111;
    color: #ff69b4;                     /* hot pink text */
    cursor: pointer;
  }
  button:hover { background: #ff69b4; color: #000; }
  input[type="checkbox"] { accent-color: #ff69b4; } /* HOT PINK CHECKBOXES */
  fieldset {
    border:1px solid #555;
    border-radius:.5rem;
    padding: .75rem;
  }
  legend { padding: 0 .4rem; color:#ff69b4; }
  .muted { color:#aaa }
  label + label { margin-left: 1rem }
</style>

<h1>Password Generator</h1>

<div class="row">
  <label>Length:
    <input id="len" type="number" min="6" max="64" value="16">
  </label>
</div>

<fieldset class="row">
  <legend>Mode</legend>
  <label><input type="radio" name="mode" id="modeRandom" checked> Random characters</label>
  <label><input type="radio" name="mode" id="modePattern"> Pattern: [Example: SpaghettiSauce28!] (exact fit)</label>
</fieldset>

<div class="row" id="randomOpts">
  <div class="row">
    <label><input id="lower" type="checkbox" checked> a–z</label>
    <label><input id="upper" type="checkbox" checked> A–Z</label>
    <label><input id="digits" type="checkbox" checked> 0–9</label>
    <label><input id="symbols" type="checkbox" checked> Symbols</label>
  </div>
</div>

<div class="row" id="sharedOpts">
  <label><input id="noAmbig" type="checkbox"> Exclude lookalikes (O0, l1, I|, etc.)</label>
  <label><input id="avoidWords" type="checkbox" checked> Avoid inappropriate words</label>
  <label><input id="camelCase" type="checkbox" checked> Capitalize Words </label>
</div>

<div class="row">
  <button id="gen">Generate</button>
  <button id="copy">Copy</button>
</div>

<div class="row out" id="pw" aria-live="polite"></div>
<div class="row muted" id="msg"></div>

<script>
(async function () {
  // Character sets
  const ambig = /[O0l1I|{}\[\]\(\)\/\\,;:\.`'"]/g;
  const sets = {
    lower: "abcdefghijklmnopqrstuvwxyz",
    upper: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    digits: "0123456789",
    symbols: "!@#$%^&*_-+=~:?<>{}[]()|/\\.,;"
  };

  // -------- Fallback wordlists (used only if data/*.txt not found) --------
  // Adjectives + a few -ly adverbs for variety; lengths 3..12 emphasized
  const FALLBACK_ADJ = [
    "big","odd","raw","icy","apt","fit","sad","mad","new","old","red","tan","shy","sly","dim",
    "fair","calm","cool","warm","neat","true","mere","pure","lush","kind","tidy","brisk","sharp",
    "brave","quick","quiet","proud","happy","sunny","rainy","spicy","crisp","clear","smart","eager",
    "bright","gentle","mighty","little","narrow","humble","smooth","sparkly","steady","cheery",
    "curious","playful","patient","fearless","dynamic","vivid","sturdy","cheerful","friendly",
    "graceful","powerful","stubborn","colorful","thoughtful","brilliant","efficient","confident",
    "adventurous","courageous","harmonious","meticulous","generous","glorious","victorious",
    "swift","bold","sleek","sober","solid","spry","stern","spruce","sporty","saintly","sage",
    "noble","nimble","gentle","silent","clever","bright","rustic","modern","classic","urban",
    "rural","shiny","shadowy","stormy","breezy","foggy","dusty","golden","silver","crimson",
    "amber","scarlet","amber","ivory","onyx","teal","violet","verdant","willful","witty","zesty",
    "lively","jolly","merry","jazzy","snappy","snug","cozy","roomy","airy","roomy","tasty",
    "savory","buttery","silky","soapy","leafy","woody","gritty","snowy","rainy","windy","blurry",
    "boldly","quickly","slowly","softly","brightly","bravely","surely","plain","prime","grand",
    "elegant","fancy","rapid","stern","eager","steady","wild","wise","worthy","zany","gentle",
    "frozen","fiery","stormy","sunlit","starry","dusky","murky","moody","peppy","perky","plucky"
  ];

  // Nouns; lengths 3..12 emphasized and mix of nature/objects/roles
  const FALLBACK_NOUN = [
    "cat","dog","fox","owl","ant","bee","ray","sun","sky","sea","gem","orb","map","key","cup",
    "wolf","bear","deer","hawk","kite","star","moon","lake","tree","ship","rock","rose","book","coin",
    "tiger","eagle","otter","panda","river","cloud","apple","stone","flame","shark","storm","plane",
    "falcon","canyon","forest","planet","meadow","rocket","anchor","beacon","castle","harbor","bridge",
    "phoenix","thunder","voyager","citadel","compass","scholar","whisper","lantern","orchard","compass",
    "mountain","guardian","engineer","sentinel","silvermoon","sapphire","avalanche","citizen","harvest",
    "ranger","sailor","runner","artist","pioneer","captain","pilot","guardian","tunnel","harvest",
    "meadow","cavern","desert","island","valley","village","market","station","harvest","beaconry",
    "summit","prairie","cypress","willow","maple","lotus","thicket","granite","marble","crystal",
    "gadget","camera","tablet","server","socket","module","widget","engine","switch","router","sensor",
    "harpoon","battery","compass","journal","portal","signal","festival","planet","citadel","harborer"
  ];

  // -------- Load lists (prefer external data/*.txt, else fallback) --------
  const loadList = async (path) => {
    try {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) throw new Error(path + " not found");
      const text = await res.text();
      return new Set(text.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(Boolean));
    } catch {
      return new Set(); // fail silently; we'll use fallback
    }
  };

  let BAD = await loadList("./data/badwords.txt");
  let COMMON = await loadList("./data/common_words.txt");
  let ADJ = await loadList("./data/adjectives.txt");
  let NOUN = await loadList("./data/nouns.txt");

  if (ADJ.size === 0) ADJ = new Set(FALLBACK_ADJ);
  if (NOUN.size === 0) NOUN = new Set(FALLBACK_NOUN);

  // -------- Helpers --------
  function randomInt(max) {
    if (max <= 0) return 0;
    const u32 = new Uint32Array(1);
    const limit = Math.floor(0x100000000 / max) * max;
    let r;
    do { crypto.getRandomValues(u32); r = u32[0]; } while (r >= limit);
    return r % max;
  }

  function getCharset(opts) {
    let cs = "";
    if (opts.lower)  cs += sets.lower;
    if (opts.upper)  cs += sets.upper;
    if (opts.digits) cs += sets.digits;
    if (opts.symbols) cs += sets.symbols;
    if (opts.noAmbig) cs = cs.replace(ambig, "");
    return cs;
  }

  function generateRandom(len, cs, mustSets) {
    if (cs.length < 4) throw new Error("Choose at least one character set.");
    const picks = [];
    for (const s of mustSets) picks.push(s.charAt(randomInt(s.length)));
    for (let i = picks.length; i < len; i++) picks.push(cs.charAt(randomInt(cs.length)));
    for (let i = picks.length - 1; i > 0; i--) {
      const j = randomInt(i + 1);
      [picks[i], picks[j]] = [picks[j], picks[i]];
    }
    return picks.join("");
  }

  const deLeetMap = {'0':'o','1':'i','!':'i','3':'e','4':'a','@':'a','5':'s','$':'s','7':'t','8':'b','9':'g'};
  function normalizeForCheck(pw) {
    const lower = pw.toLowerCase();
    let deLeet = "";
    for (const ch of lower) deLeet += (deLeetMap[ch] || ch);
    const lettersOnly = deLeet.replace(/[^a-z]/g, "");
    return { deLeet, lettersOnly };
  }
  function isInappropriate(pw, useCommon) {
    const { deLeet, lettersOnly } = normalizeForCheck(pw);
    for (const w of BAD) { if (deLeet.includes(w) || lettersOnly.includes(w)) return true; }
    if (useCommon && COMMON.size) {
      for (const w of COMMON) {
        if (w.length < 4) continue;
        if (deLeet.includes(w) || lettersOnly.includes(w)) return true;
      }
    }
    for (const w of BAD) {
      if (new RegExp(`${w}\\d+`).test(deLeet)) return true;
      if (new RegExp(`\\d+${w}`).test(deLeet)) return true;
    }
    return false;
  }

  function toTitle(s) { return s ? s[0].toUpperCase() + s.slice(1) : s; }

  function buildLengthIndex(wordSet, bannedSet) {
    const idx = new Map();
    for (const w of wordSet) {
      if (bannedSet && bannedSet.has(w)) continue;
      const L = w.length;
      if (!idx.has(L)) idx.set(L, []);
      idx.get(L).push(w);
    }
    return idx;
  }

  let ADJ_BY_LEN = buildLengthIndex(ADJ, BAD);
  let NOUN_BY_LEN = buildLengthIndex(NOUN, BAD);

  function generatePattern(opts) {
    // exact fit: (adj/adverb length + noun length) == (len - 3)
    const target = opts.len - 3; // 2 digits + 1 symbol
    if (target <= 1) throw new Error("Length too small. Increase length.");

    const pairs = [];
    for (const [aLen, aWords] of ADJ_BY_LEN.entries()) {
      const nLen = target - aLen;
      const nWords = NOUN_BY_LEN.get(nLen);
      if (nLen > 0 && nWords && nWords.length && aWords.length) {
        pairs.push([aLen, nLen]);
      }
    }
    if (!pairs.length) {
      const minAdj = Math.min(...[...ADJ_BY_LEN.keys()]);
      const minNoun = Math.min(...[...NOUN_BY_LEN.keys()]);
      const minPossible = 3 + minAdj + minNoun;
      throw new Error(
        `No adjective+noun combo matches length ${opts.len}. ` +
        `Try a different length or expand lists. (Minimum feasible around ${minPossible}.)`
      );
    }

    const [aPick, nPick] = pairs[randomInt(pairs.length)];
    const adjArr = ADJ_BY_LEN.get(aPick);
    const nounArr = NOUN_BY_LEN.get(nPick);
    const adj = adjArr[randomInt(adjArr.length)];
    const noun = nounArr[randomInt(nounArr.length)];
    const wordPart = opts.camelCase ? (toTitle(adj) + toTitle(noun)) : (adj + noun);

    // 2 digits + 1 symbol
    const num = String(randomInt(100)).padStart(2, "0");
    let symbols = sets.symbols;
    if (opts.noAmbig) symbols = symbols.replace(ambig, "");
    const sym = symbols.charAt(randomInt(symbols.length));

    return wordPart + num + sym; // exact length == opts.len
  }

  async function makePassword(opts) {
    const MAX_TRIES = 200;

    if (opts.mode === "pattern") {
      for (let i = 0; i < MAX_TRIES; i++) {
        const cand = generatePattern(opts);
        if (!opts.avoidWords || !isInappropriate(cand, true)) return cand;
      }
      throw new Error("Could not generate a clean pattern password. Expand lists or disable 'avoid words'.");
    } else {
      const mustSets = [], allSets = [];
      if (opts.lower)  { mustSets.push(sets.lower);  allSets.push(sets.lower); }
      if (opts.upper)  { mustSets.push(sets.upper);  allSets.push(sets.upper); }
      if (opts.digits) { mustSets.push(sets.digits); allSets.push(sets.digits); }
      if (opts.symbols){ mustSets.push(sets.symbols);allSets.push(sets.symbols); }
      let cs = allSets.join("");
      if (opts.noAmbig) cs = cs.replace(ambig, "");
      for (let i = 0; i < MAX_TRIES; i++) {
        const cand = generateRandom(opts.len, cs, mustSets);
        if (!opts.avoidWords || !isInappropriate(cand, true)) return cand;
      }
      throw new Error("Could not generate a clean password. Try different settings.");
    }
  }

  // UI wiring
  const $ = id => document.getElementById(id);
  const randomOpts = document.getElementById("randomOpts");
  const modeRandom = $("modeRandom");
  const modePattern = $("modePattern");

  function updateModeUI() { randomOpts.style.display = modeRandom.checked ? "" : "none"; }
  modeRandom.addEventListener("change", updateModeUI);
  modePattern.addEventListener("change", updateModeUI);
  updateModeUI();

  $("gen").onclick = async () => {
    const opts = {
      mode: modePattern.checked ? "pattern" : "random",
      len: Math.max(6, Math.min(64, parseInt(($("len")?.value) || "16", 10))),
      lower: $("lower")?.checked,
      upper: $("upper")?.checked,
      digits: $("digits")?.checked,
      symbols: $("symbols")?.checked,
      noAmbig: $("noAmbig").checked,
      avoidWords: $("avoidWords").checked,
      camelCase: $("camelCase").checked
    };
    try {
      const pw = await makePassword(opts);
      $("pw").textContent = pw;
      const listsLoaded = (BAD.size || COMMON.size);
      $("msg").textContent =
        `Generated locally. ${listsLoaded ? "Clean-word filter active." : "Word filter inactive (lists not loaded)."}`;
    } catch (e) {
      $("pw").textContent = "";
      $("msg").textContent = e.message;
    }
  };

  $("copy").onclick = async () => {
    const text = $("pw").textContent;
    if (!text) return;
    try { await navigator.clipboard.writeText(text); $("msg").textContent = "Copied to clipboard."; }
    catch { $("msg").textContent = "Copy failed. Copy manually."; }
  };
})();
</script>
</html>
